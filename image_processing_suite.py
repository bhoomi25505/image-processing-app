# -*- coding: utf-8 -*-
"""Image Processing Suite

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nJCvkQ-vgyARh3irjLpD_uu2SL1r7Zj2
"""

import streamlit as st
import cv2
import numpy as np
from PIL import Image
import io
import os

# --- 1. Utility Functions for Image Processing (OpenCV/NumPy Backend) ---

def load_image_from_bytes(uploaded_file):
    """Reads an uploaded file (bytes) into an OpenCV (BGR) image array."""
    # Read the file into memory
    file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)
    # Decode the image using OpenCV (returns BGR format)
    img = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)
    return img

def get_image_properties(img):
    """Calculates and returns the properties of the image."""
    h, w = img.shape[:2]
    # Memory usage: 3 (color channels) * H * W * 1 (byte per pixel)
    mem_bytes = img.nbytes
    mem_mb = mem_bytes / (1024 * 1024)
    return {
        "width": w,
        "height": h,
        "pixels": w * h,
        "memory_mb": f"{mem_mb:.2f} MB",
        "dtype": str(img.dtype)
    }

def convert_to_black_and_white(img):
    """Converts the image to grayscale and then thresholds it to B&W."""
    # Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # Apply a simple binary threshold (a form of B&W)
    # Pixels above 127 become white (255), below become black (0)
    _, bw_img = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
    # Convert back to 3-channel BGR for consistent display in Streamlit
    bw_img_bgr = cv2.cvtColor(bw_img, cv2.COLOR_GRAY2BGR)
    return bw_img_bgr

def rotate_image(img, angle):
    """Rotates the image by 90, 180, or 270 degrees."""
    if angle == 90:
        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)
    elif angle == 180:
        return cv2.rotate(img, cv2.ROTATE_180)
    elif angle == 270:
        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)
    else:
        return img

def mirror_image(img):
    """Flips the image horizontally (mirror image)."""
    # 1: horizontal flip, 0: vertical flip, -1: both
    return cv2.flip(img, 1)

def find_objects_contours(img):
    """Uses classic computer vision (Canny + Contours) to find objects."""
    # Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # Apply Gaussian blur to reduce noise before edge detection
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    # Canny Edge Detection
    edged = cv2.Canny(blurred, 50, 150)

    # Find Contours
    # cv2.RETR_EXTERNAL retrieves only the extreme outer contours
    contours, _ = cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Create a copy to draw the contours on (in BGR format)
    contour_img = img.copy()

    # Draw all found contours in a distinctive color (e.g., bright cyan)
    cv2.drawContours(contour_img, contours, -1, (255, 255, 0), 2) # BGR: Blue=255, Green=255, Red=0

    return contour_img, len(contours)

def slice_image(img, orientation, ratio):
    """Slices the image based on orientation and ratio (e.g., 50, 80, 30)."""
    h, w = img.shape[:2]

    if orientation == 'vertical':
        # Split width: 50/50, 80/20, or 30/70. We take the left/top part.
        split_point = int(w * (ratio / 100))
        # Slice columns (width)
        return img[:, :split_point]

    elif orientation == 'horizontal':
        # Split height
        split_point = int(h * (ratio / 100))
        # Slice rows (height)
        return img[:split_point, :]

    return img

def create_grid(img, rows, cols):
    """Divides the image into a grid of RxC cells and returns a list of cells."""
    h, w = img.shape[:2]
    H_cell = h // rows
    W_cell = w // cols

    grid_cells = []
    for r in range(rows):
        for c in range(cols):
            y_start = r * H_cell
            y_end = (r + 1) * H_cell
            x_start = c * W_cell
            x_end = (c + 1) * W_cell

            # Slice and append the cell
            cell = img[y_start:y_end, x_start:x_end]
            grid_cells.append(cell)

    return grid_cells


# --- 2. Streamlit Application Layout and Logic ---

def main():
    st.set_page_config(layout="wide", page_title="Advanced Image Processor")
    st.title("Image Processing Suite (CV/Pillow Backend)")
    st.markdown("Upload an image and use the sidebar tools to perform various classical computer vision operations.")

    # State management for the current image
    if 'current_img' not in st.session_state:
        st.session_state.current_img = None
    if 'original_img' not in st.session_state:
        st.session_state.original_img = None

    # --- Sidebar: Image Upload and Reset ---
    st.sidebar.header("1. Upload Image")
    uploaded_file = st.sidebar.file_uploader(
        "Choose an image file (PNG, JPG, JPEG)",
        type=["png", "jpg", "jpeg"]
    )

    if uploaded_file is not None:
        try:
            # Check if a new file was uploaded or if we need to load the image
            if st.session_state.original_img is None or uploaded_file.name != st.session_state.uploaded_file_name:
                img_bgr = load_image_from_bytes(uploaded_file)
                st.session_state.original_img = img_bgr
                st.session_state.current_img = img_bgr.copy()
                st.session_state.uploaded_file_name = uploaded_file.name
                st.toast(f"Image '{uploaded_file.name}' loaded successfully!", icon='üñºÔ∏è')

            # Show image properties
            if st.session_state.current_img is not None:
                properties = get_image_properties(st.session_state.original_img)
                st.sidebar.subheader("Image Properties")
                st.sidebar.json(properties)

                # Reset button
                if st.sidebar.button("üîÑ Reset Image to Original", type="primary"):
                    st.session_state.current_img = st.session_state.original_img.copy()
                    st.toast("Image reset!", icon='‚úÖ')

        except Exception as e:
            st.error(f"Error loading or processing image: {e}")
            st.session_state.current_img = None
            st.session_state.original_img = None
    else:
        st.info("Please upload an image to begin.")
        st.session_state.current_img = None
        st.session_state.original_img = None


    # --- Main Content Area: Display and Processing ---

    if st.session_state.current_img is not None:

        # Convert BGR to RGB for Streamlit display
        img_rgb = cv2.cvtColor(st.session_state.current_img, cv2.COLOR_BGR2RGB)

        col_img, col_tools = st.columns([2, 1])

        with col_img:
            st.subheader("Current Image")
            st.image(img_rgb, caption="Processed Image", use_column_width=True)

        with col_tools:
            st.header("2. Image Operations")

            # --- Color / Mirror ---
            st.subheader("Color & Flip")
            if st.button("‚ö´ Change to Black and White"):
                st.session_state.current_img = convert_to_black_and_white(st.session_state.current_img)
                st.success("Converted to B&W.")
                st.rerun()

            if st.button("‚ÜîÔ∏è Convert to Mirror Image (Horizontal Flip)"):
                st.session_state.current_img = mirror_image(st.session_state.current_img)
                st.success("Flipped horizontally.")
                st.rerun()

            # --- Rotation ---
            st.subheader("Rotation")
            rotation_angle = st.radio("Select Angle to Rotate:", (90, 180, 270), index=None, horizontal=True)
            if rotation_angle:
                st.session_state.current_img = rotate_image(st.session_state.current_img, rotation_angle)
                st.success(f"Rotated by {rotation_angle} degrees.")
                st.rerun()

            # --- Object Detection (Contours) ---
            st.subheader("Object Finding (Classical CV)")
            if st.button("üîç Find Objects (Contours)"):
                # Run the contour detection logic
                processed_img, count = find_objects_contours(st.session_state.current_img)
                st.session_state.current_img = processed_img
                st.success(f"Found {count} potential objects/contours!")
                st.rerun()

        st.divider()

        # --- Slicing/Cutting Operations ---
        st.header("3. Cutting and Slicing")

        col1, col2, col3 = st.columns(3)

        with col1:
            st.subheader("50/50 Cuts")
            if st.button("‚úÇÔ∏è Vertical 50/50 Cut"):
                st.session_state.current_img = slice_image(st.session_state.current_img, 'vertical', 50)
                st.success("Cut to left 50%.")
                st.rerun()
            if st.button("‚úÇÔ∏è Horizontal 50/50 Cut"):
                st.session_state.current_img = slice_image(st.session_state.current_img, 'horizontal', 50)
                st.success("Cut to top 50%.")
                st.rerun()

        with col2:
            st.subheader("Ratio Cuts (80/20 or 30/70)")
            cut_option = st.radio("Select Ratio Cut:", ("Vertical 30/70 (Left 30%)", "Vertical 80/20 (Left 80%)", "Horizontal 30/70 (Top 30%)", "Horizontal 80/20 (Top 80%)"), index=None)

            if st.button("Apply Ratio Cut", disabled=cut_option is None):
                if cut_option == "Vertical 30/70 (Left 30%)":
                    st.session_state.current_img = slice_image(st.session_state.current_img, 'vertical', 30)
                    st.success("Cut to left 30%.")
                elif cut_option == "Vertical 80/20 (Left 80%)":
                    st.session_state.current_img = slice_image(st.session_state.current_img, 'vertical', 80)
                    st.success("Cut to left 80%.")
                elif cut_option == "Horizontal 30/70 (Top 30%)":
                    st.session_state.current_img = slice_image(st.session_state.current_img, 'horizontal', 30)
                    st.success("Cut to top 30%.")
                elif cut_option == "Horizontal 80/20 (Top 80%)":
                    st.session_state.current_img = slice_image(st.session_state.current_img, 'horizontal', 80)
                    st.success("Cut to top 80%.")
                st.rerun()

        with col3:
            # --- Grid Generation ---
            st.subheader("Grid Creation (3 x 5)")
            if st.button("üñºÔ∏è Make 3 x 5 Grid"):
                grid_cells = create_grid(st.session_state.current_img, 3, 5)

                # Display the grid in a new section
                st.subheader("3 x 5 Grid Result")
                rows_cols = st.columns(5)

                for idx, cell in enumerate(grid_cells):
                    # Convert to RGB for display
                    cell_rgb = cv2.cvtColor(cell, cv2.COLOR_BGR2RGB)
                    # Place the image in the correct column
                    with rows_cols[idx % 5]:
                        st.image(cell_rgb, caption=f"Cell {idx+1}", use_column_width=True)

                st.success("Image split into a 3x5 grid.")
                # We don't rerun here as the main image state is not changed, only displayed.


if __name__ == "__main__":
    main()